<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: graphs/shortest-path/dijkstra.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: graphs/shortest-path/dijkstra.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function (exports) {
  'use strict';

  var dijkstra = (function() {

    var Heap = require('../../data-structures/heap.js').Heap,
        current,
        visited,
        distance,
        unvisited;

    /**
     * Creates a new node instance.
     *
     * @constructor
     * @private
     * @param {Number} id Id of the node.
     * @param {Number} distance Distance from the beginning.
     */
    function Node(id, distance) {
      this.node = id;
      this.distance = distance;
    }

    /**
     * Compares the distances between two nodes.
     *
     * @private
     * @param {Node} a 1st node.
     * @param {Node} b 2nd node.
     * @returns {number} diff between node distances.
     */
    function compareNodesDistance(a, b) {
      return b.distance - a.distance;
    }

    /**
     * Initialize all variables used for the algorithm.
     *
     * @private
     * @param {number} src Start node.
     */
    function init(src, graph) {
      var currentTemp;
      current = {};
      visited = [];
      distance = [];
      unvisited = new Heap(compareNodesDistance);
      for (var i = 0; i &lt; graph.length; i += 1) {
        currentTemp = new Node();
        if (src === i) {
          currentTemp.distance = 0;
        } else {
          currentTemp.distance = Infinity;
        }
        currentTemp.node = i;
        visited[i] = false;
        distance[i] = currentTemp;
        unvisited.add(currentTemp);
      }
      current.node = src;
      current.distance = 0;
    }

    /**
     * Dijkstra's shortest path algorithm. Finds the minimum 
     * distance between two given nodes using a distance matrix.&lt;br>&lt;br>
     * For the implementation is not used the most suitable data structure
     * (Fibonacci heap) but the Binary heap gives also good results.
     *
     * @public
     * @module graphs/shortest-path/dijkstra
     * @param {Number} src Source node.
     * @param {Number} dest Destination node.
     * @param {Array} graph A distance matrix of the graph.
     * @returns {Number} The shortest distance between two nodes.
     * 
     * @example
     * var dijkstra = require('path-to-algorithms/src/graphs/shortest-path/dijkstra').dijkstra;
     * var distMatrix = [[Infinity, 7,        9,        Infinity, Infinity, 16],
     *                   [7,        Infinity, 10,       15,       Infinity, Infinity],
     *                   [9,        10,       Infinity, 11,       Infinity, 2],
     *                   [Infinity, 15,       11,       Infinity, 6,        Infinity],
     *                   [Infinity, Infinity, Infinity, 6,        Infinity, 9],
     *                   [16,       Infinity, 2,        Infinity, 9,        Infinity]];
     * var shortestDist = dijkstra(0, 2, distMatrix); // 9
     */
    return function (src, dest, graph) {
      var  tempDistance = 0;
      init(src, graph);
      while (current.node !== dest &amp;&amp; isFinite(current.distance)) {
        for (var i = 0; i &lt; graph.length; i += 1) {
          if (current.node !== i &amp;&amp; //if it's not the current node
            !visited[i] &amp;&amp; //and if we haven't visited this node
            Number.isFinite(graph[i][current.node])) { //and this node is sibling of the current...

            tempDistance = current.distance + graph[i][current.node];
            if (tempDistance &lt; distance[i].distance) {
              distance[i].distance = tempDistance;
              current.distance = tempDistance;
              unvisited.update(current);
            }
          }
        }
        visited[current.node] = true;
        current = unvisited.extract();
      }
      return distance[dest].distance;
    };
  
  })();

  exports.dijkstra = dijkstra;

})(typeof window === 'undefined' ? module.exports : window);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="topological-sort.html">graphs/others/topological-sort</a></li><li><a href="bfs.html">graphs/searching/bfs</a></li><li><a href="dfs.html">graphs/searching/dfs</a></li><li><a href="bellman-ford.html">graphs/shortest-path/bellman-ford</a></li><li><a href="dijkstra.html">graphs/shortest-path/dijkstra</a></li><li><a href="floyd-warshall.html">graphs/shortest-path/floyd-warshall</a></li></ul><h3>Classes</h3><ul><li><a href="Edge.html">Edge</a></li><li><a href="Graph.html">Graph</a></li><li><a href="Vertex.html">Vertex</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri Jan 09 2015 21:22:24 GMT+0200 (EET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
